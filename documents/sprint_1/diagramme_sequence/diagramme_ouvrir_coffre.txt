@startuml

title "Ouvrir coffre et rammasser trésor - Sequence Diagram"

actor player as player
== Au Préalable:\n Création et déroulement d'une partie ... ==
loop While jeu non fini
	player -> Jeu : controles(cmd)
	opt cmd est l'ouverture d'un coffre
		activate Jeu
		Jeu -> Jeu : etreProcheCaseTresor()	
		note right: return [-1,-1] si pas de trésor ou [x,y]: position du coffre 
		opt joueur à proximité d'une case tresor
			Jeu -> Labyrinthe : getCase(x,y)
			activate Labyrinthe
			Labyrinthe --> Jeu : case
			deactivate Labyrinthe
			Jeu -> CaseTresor : estOuvert()
			activate CaseTresor
			CaseTresor --> Jeu: True or False 
			deactivate CaseTresor
			alt le trésor est fermé
				Jeu -> CaseTresor : ouvrirTresor()
				activate CaseTresor
				deactivate CaseTresor
			else le trésor est ouvert
				Jeu -> CaseTresor : getContenu()
				activate CaseTresor
				Jeu <-- CaseTresor : Tresor t
				deactivate CaseTresor
				Jeu -> Jeu : ramasser = True
				note right: déclaration d'un booléen
				alt t instance of Potion
					Jeu -> Joueur: getInventaire()
					activate Joueur
					Jeu <-- Joueur: arrayList<Potion> listPotion
					deactivate Joueur
					alt inventaire plein
						Jeu -> Jeu: ramasser = False						
					else inventaire non plein
						Jeu -> Joueur: ramasserPotion(t)
						activate Joueur
						deactivate Joueur
					end
				else t instance of Arme
					Jeu -> Joueur : getArme()
					activate Joueur
					Jeu <-- Joueur: Arme ancienneArme
					deactivate Joueur
					Jeu -> Joueur: setArme(t)
					activate Joueur
					deactivate Joueur
				end
				opt ramasser == True
					alt t instance of Arme		
						Jeu -> CaseTresor: case.setContenu(ancienneArme)
						activate CaseTresor
						deactivate CaseTresor
					else t instance of Potion 
						create CaseVide
						Jeu -> CaseVide: caseV = new CaseVide()
						Jeu -> Labyrinthe: setCase(x, y, caseV)
						activate Labyrinthe
						deactivate Labyrinthe
						destroy CaseTresor					
					end
				end
			end 
		end	
	end
	deactivate Jeu
end
@enduml